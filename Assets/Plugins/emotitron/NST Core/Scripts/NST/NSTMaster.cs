//Copyright 2018, Davin Carten, All rights reserved

#if PUN_2_OR_NEWER || MIRROR || !UNITY_2019_1_OR_NEWER

using UnityEngine;
using emotitron.Compression;
using emotitron.Utilities.GUIUtilities;
using System.Collections.Generic;
using emotitron.Debugging;

#if UNITY_EDITOR
using UnityEditor;
#endif
namespace emotitron.NST
{

	[DisallowMultipleComponent]
	//[ExecuteInEditMode]
	public class NSTMaster : Singleton<NSTMaster>
	{
		public const string DEFAULT_GO_NAME = "NST Master";

		/// TODO: Make these sizes user controlled
		// the num of bits used to count how many bytes an update used - this is a bit arbitrary
		public const int UPDATELENGTH_BYTE_COUNT_SIZE = 8;
		public const int MAX_BYTES_PER_NST = 255; // 2 ^ UPDATELENGTH_BYTE_COUNT_SIZE

		public const int FRAME_COUNT = 60;

		// Preallocated reusable byte arrays for the bitstream and outstream
		public static byte[] bitstreamByteArray = new byte[2048];
		public static byte[] outstreamByteArray = new byte[2048];

		// List of components capable of creating offtick updates
		public static List<IOfftickSrc> iOfftickSrc = new List<IOfftickSrc>();

		[System.NonSerialized]
		public MasterNetAdapter mna;

//#if UNITY_EDITOR
//		private bool needsEditorModePostAwakeCheck;
//#endif
		protected override void Awake()
		{
			base.Awake();

			mna = GetComponent<MasterNetAdapter>();
			if (mna == null)
				mna = gameObject.AddComponent<MasterNetAdapter>();


//#if UNITY_EDITOR
//			// Don't run awake if this is not runtime.
//			if (!Application.isPlaying)
//			{
//				EnsureNSTMasterConforms();
//				needsEditorModePostAwakeCheck = true;
//				return;
//			}
//#endif
			DontDestroyOnLoad(gameObject);
		}

		/// <summary>
		/// Force NSTMaster to add itself correctly on load.
		/// </summary>
		[RuntimeInitializeOnLoadMethod(RuntimeInitializeLoadType.BeforeSceneLoad)]
		private static void EnsureMasterExistsInScene()
		{
			//Debug.Log("Force creation of NSTMaster");
			EnsureExistsInScene(DEFAULT_GO_NAME);
		}


		private void Update()
		{

			if (!MasterNetAdapter.NetworkIsActive)
				return;

			for (int i = 0; i < NSTTools.allNsts.Count; i++)
			{
				NSTTools.allNsts[i].MasterUpdate();
			}
		}

		private static int _frameCounter;
		public static int FrameCounter
		{
			get { return _frameCounter; }
			/// TODO: this likely is needless complex now
			private set { _frameCounter = (value >= FRAME_COUNT) ? value - FRAME_COUNT :  (value < 0) ? value + FRAME_COUNT : value; }
		}

		private static int ontickSendsDue;
		private static bool offtickSendDue;

		private static int fixedUpdateCounter;
		private void FixedUpdate()
		{
			if (!MasterNetAdapter.ReadyToSend)
				return;

			/// Send in FixedUpdate version
			fixedUpdateCounter++;

			if (fixedUpdateCounter >= HeaderSettings.single.TickEveryXFixed)
			{
				PollForUpdates(_frameCounter, false);
				FrameCounter++;
				fixedUpdateCounter = 0;
			}
			else
			{
				// Check for Offticks on nsts marked as allowing offtick
				PollForUpdates(FRAME_COUNT, true);
			}
		}

		// Create the master bitstream and poll for updates
		private static void PollForUpdates(int updateCounter, bool isOfftick)
		{
			UdpBitStream bitstream = new UdpBitStream(NSTMaster.bitstreamByteArray);
			UdpBitStream outstream = new UdpBitStream();

			bitstream.WriteInt(updateCounter, 6);

			NSTSceneManager.Serialize(ref bitstream);

			bool updatesFound = PollAllForNSTUpdates(ref bitstream, isOfftick ? NSTTools.allNstsWithOfftick : NSTTools.allNsts, updateCounter, isOfftick);

			if (!isOfftick)
				MasterRTT.Send(ref bitstream, updateCounter);

			/// Additional Data after NST Updates added to stream here
			
			// Send every tick, or if anything offtick was found
			if (updatesFound /*|| !isOfftick*/)
			{
				MasterNetAdapter.SendUpdate(ref bitstream, ref outstream);
			}
			
		}

		private void LateUpdate()
		{
			for (int i = 0; i < NSTTools.allNsts.Count; i++)
				NSTTools.allNsts[i].MasterLateUpdate();
		}

		/// <summary>
		/// Ping all owned NSTs for any due updates (fires on network ticks, generated by the NSTMaster FixedUpdate()). Passes the bitstream to that NST.
		/// </summary>
		public static bool PollAllForNSTUpdates(ref UdpBitStream bitstream, List<NetworkSyncTransform> nsts, int updateCounter, bool isOfftick)
		{
			if (!MasterNetAdapter.ServerIsActive && !MasterNetAdapter.ClientIsActive)
				return false;
			
			bool foundUpdate = false;
			int count = nsts.Count;
			for (int i = 0; i < count; ++i)
			{
				foundUpdate |= nsts[i].PollForUpdate(ref bitstream, updateCounter, isOfftick);
			}

			// Write the end of stream marker of 00
			bitstream.WriteBool(false);

			IntegrityCheck.WriteCheck(ref bitstream);

			return foundUpdate;
		}

		private static NetworkSyncTransform lastNST;

		/// <summary>
		/// Reads update headers for each NST frame update in the incoming bitstream, and passes the bitstream to that NST to read out its
		/// update information.
		/// </summary>
		/// <param name="mirror">True if this is the server, and this is the incoming bitstream. Tells the server that the outstream
		/// needs to be populated for retransmission to all clients. Also false if this is the server running its own outgoing update.</param>
		public static void ReceiveUpdate(ref UdpBitStream bitstream, ref UdpBitStream outstream, bool mirror, int senderId)
		{
			// Create a new bitstream to ensure ptr is at 0. Same data as master though.
			bitstream.ptr = 0;

			int frameid = bitstream.ReadInt(6);
			if (mirror)
				outstream.WriteInt(frameid, 6);

			bool isOfftick = frameid == FRAME_COUNT;

			int sceneIndex = NSTSceneManager.Deserialize(ref bitstream, ref outstream, mirror);
			bool sceneOutOfSync = HeaderSettings.single.includeSceneIndex && sceneIndex != NSTSceneManager.CurrentSceneIndex;

			if (sceneOutOfSync)
				Debug.LogWarning(frameid + " Out of sync " + sceneIndex + " " + NSTSceneManager.CurrentSceneIndex);


			// remove this safety once working
			//TEST
			int safety = 0;
			UpdateType updateType;
			do
			{
				safety++;
				BandwidthUsage.Start(ref bitstream, BandwidthLogType.UpdateRcv);

				//stop looking when header is EOS
				bool notEOS = bitstream.ReadBool();
				int mirrorUpdateStartPtr = outstream.ptr;
				BandwidthUsage.AddUsage(ref bitstream, "NotEOS");

				if (mirror)
					outstream.WriteBool(notEOS);

				if (!notEOS)
				{
					break;
				}

				// First three bits are the msgtype 
				//TODO this might only need to be two
				updateType = (UpdateType)bitstream.ReadInt(3);
				BandwidthUsage.AddUsage(ref bitstream, "UpdateType");

				int updateBitstreamPos = outstream.ptr;
				if (mirror)
					outstream.WriteInt((int)updateType, 3);

				// Next variable is the NstId - get it to know where to send the rest of the bitstream
				uint nstid = bitstream.ReadUInt(HeaderSettings.single.BitsForNstId);
				BandwidthUsage.AddUsage(ref bitstream, "NstId");

				if (mirror)
					outstream.WriteUInt(nstid, HeaderSettings.single.BitsForNstId);

				lastNST = NSTTools.GetNstFromId(nstid);
				BandwidthUsage.SetName(lastNST);

				int updatelength = bitstream.ReadInt(UPDATELENGTH_BYTE_COUNT_SIZE);
				if (mirror)
					outstream.WriteInt(updatelength, UPDATELENGTH_BYTE_COUNT_SIZE);
				BandwidthUsage.AddUsage(ref bitstream, "DataLength");

				//Note the starting pos in stream
				int bodyPtr = bitstream.ptr;
				// The start pos for modifying update lenght for mirror
				int mirrorBodyPtr = outstream.ptr;

				XDebug.LogWarning(!XDebug.logWarnings ? null :
					("Incoming Update for nstid: " + nstid + " was from a different scene. Ignoring update to avoid data corruption due to different compression settings."), sceneOutOfSync);

				XDebug.Log(!XDebug.logInfo ? null :
					//Debug.Log(
					("Message for an NST Object " + nstid + " arrived but that object does not exist. (yet/anymore?) This is normal during startup and shutdown."), lastNST == null);
				
				/// Skip reading if the target NST doesn't exist, or if this we compressed with a different scene (codec mismatch likely)
				if (lastNST == null || sceneOutOfSync)
				{
					if (sceneOutOfSync)
						Debug.LogWarning(frameid + " skipped entirely due to sceneID mismatch");
					// Forward to the next update start in the incoming stream.
					bitstream.ptr = bodyPtr + (updatelength << 3);
					// rewind to the EOS marker and pretend this arrival never occured for the outgoing mirror stream.
					if (mirror)
					{
						/// TODO : Rather than jump ahead, Server should bulk copy the ignored data to outstream in case other clients can use it.
						outstream.ptr = mirrorUpdateStartPtr;
					}
					continue;
				}

				// Tell this nst to read its mail. updateType may get modified by server receive for things like teleport.
				Frame frame = lastNST.ReadUpdate(ref bitstream, ref outstream, frameid, isOfftick, updateType, updatelength, sceneIndex, sceneOutOfSync, mirror);
				updateType = frame.updateType;

				// overwrite the updateType of the server outgoing in case it has changed.
				if (mirror)
					outstream.WriteIntAtPos((int)updateType, 3, updateBitstreamPos);

				//Advance ptr to next update in stream by force, in case the last update wasn't read for any reason (such as the NST leaving the game)
				bitstream.ptr = bodyPtr + (updatelength << 3);
				
				// write the update byte length for the mirror (not the same value as the incoming due to server side adjustments)
				if (mirror)
				{
					int holdPos = outstream.ptr;
					outstream.ptr = mirrorBodyPtr - UPDATELENGTH_BYTE_COUNT_SIZE;
					// get the bytesused rounded up.
					int bytes = ((holdPos - mirrorBodyPtr) >> 3) + (((holdPos - mirrorBodyPtr) % 8 == 0 ) ? 0 : 1 );
					outstream.WriteInt(bytes, UPDATELENGTH_BYTE_COUNT_SIZE);
					outstream.ptr = mirrorBodyPtr + (bytes << 3);
				}


			} while (safety < 100);

			/// NST updates are finished - any data to append to the master update can go here
			IntegrityCheck.ReadCheck(ref bitstream, ref outstream, "End of All Update Reads", mirror);

			if (!isOfftick)
				MasterRTT.Rcv(ref bitstream, ref outstream, mirror, senderId);
			BandwidthUsage.AddUsage(ref bitstream, "RTT checks");

			// Very last thing... report the bits that were used. This is conditional to the editor only
			BandwidthUsage.ReportMasterBits(ref bitstream, BandwidthLogType.MasterIn);
		}
	}
	

#if UNITY_EDITOR

	[CustomEditor(typeof(NSTMaster))]
	[CanEditMultipleObjects]
	public class NSTMasterEditor : NSTHeaderEditorBase
	{
		public override void OnEnable()
		{
			headerName = HeaderMasterName;
			headerColor = HeaderSettingsColor;
			base.OnEnable();
		}

		public override void OnInspectorGUI()
		{
			base.OnInspectorGUI();
			EditorGUILayout.HelpBox("The NST Master is a required engine singleton. It collects and sends all NST Updates, and receives and dispatches incoming updates from the network to their associated NSTs.", MessageType.None);
		}
	}
#endif
}


#endif